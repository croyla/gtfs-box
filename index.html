<!DOCTYPE html>
<html lang="ja_JP" style="overscroll-behavior: none;">
<head>
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-MBWPV5QJ5S"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'G-MBWPV5QJ5S');
	</script>
	<meta charset="utf-8" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/fontawesome.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/brands.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/solid.css" />
	<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" />
	<link rel="stylesheet" href="mini-tokyo-3d.min.css" />
	<link rel="stylesheet" href="gtfs-box.css" />
	<title>GTFS box</title>
	<meta name="description" content="A real-time 3D digital map of public transport systems with GTFS Realtime data." />
	<meta name="viewport" content="user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, width=device-width, height=device-height, initial-scale=1" />
	<meta property="og:title" content="GTFS box" />
	<meta property="og:description" content="A real-time 3D digital map of public transport systems with GTFS Realtime data." />
	<meta property="og:locale" content="en_US" />
	<link rel="canonical" href="https://nagix.github.io/gtfs-box" />
	<meta property="og:url" content="https://nagix.github.io/gtfs-box" />
	<meta property="og:site_name" content="GTFS box" />
	<meta property="og:image" content="screenshot1.jpg" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:site" content="@nagix" />
	<!-- Load MapLibre GL JS and create Mapbox GL JS compatibility shim -->
	<script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
	<script>
		console.log('[INIT] MapLibre GL JS loaded, starting patches...');

		// Intercept fetch to mock Mapbox API responses
		const originalFetch = window.fetch;
		window.fetch = function(url, options) {
			// Mock Mapbox Tilequery API for timezone lookup
			if (typeof url === 'string' && url.includes('api.mapbox.com/v4/') && url.includes('/tilequery/')) {
				console.log('Intercepted Mapbox tilequery request, returning mock timezone data');
				// Return a mock timezone response (UTC+0)
				return Promise.resolve(new Response(JSON.stringify({
					type: 'FeatureCollection',
					features: [{
						type: 'Feature',
						geometry: { type: 'Point', coordinates: [0, 0] },
						properties: { TZID: 'UTC' }
					}]
				}), {
					status: 200,
					headers: { 'Content-Type': 'application/json' }
				}));
			}
			// Pass through all other requests
			return originalFetch.apply(this, arguments);
		};

		// Patch MapLibre Map prototype BEFORE MT3D loads
		(function() {
			const MapPrototype = maplibregl.Map.prototype;

			// Store original methods
			const originalAddLayer = MapPrototype.addLayer;
			const originalGetLayer = MapPrototype.getLayer;
			const originalSetLayoutProperty = MapPrototype.setLayoutProperty;
			const originalSetPaintProperty = MapPrototype.setPaintProperty;

			// Wrap addLayer to ensure layers have metadata property
			MapPrototype.addLayer = function(layer, beforeId) {
				// Ensure the layer object has a metadata property using Object.defineProperty
				if (typeof layer === 'object' && layer !== null) {
					if (!layer.hasOwnProperty('metadata')) {
						try {
							Object.defineProperty(layer, 'metadata', {
								value: {},
								writable: true,
								enumerable: true,
								configurable: true
							});
						} catch (e) {
							// Fallback to direct assignment
							try {
								layer.metadata = {};
							} catch (e2) {
								console.warn('Could not initialize metadata on layer:', layer);
							}
						}
					}
				}
				return originalAddLayer.call(this, layer, beforeId);
			};

			// Wrap getLayer to always return a valid object with metadata
			MapPrototype.getLayer = function(id) {
				const layer = originalGetLayer.call(this, id);
				if (layer && !layer.metadata) {
					try {
						layer.metadata = {};
					} catch (e) {
						// Ignore if can't set
					}
				}
				return layer;
			};

			// Wrap setLayoutProperty to handle undefined layers gracefully
			MapPrototype.setLayoutProperty = function(layerId, name, value) {
				try {
					const layer = this.getLayer(layerId);
					if (layer) {
						return originalSetLayoutProperty.call(this, layerId, name, value);
					}
				} catch (e) {
					console.warn(`Could not set layout property ${name} on layer ${layerId}:`, e);
				}
			};

			// Wrap setPaintProperty to handle undefined layers gracefully
			MapPrototype.setPaintProperty = function(layerId, name, value) {
				try {
					const layer = this.getLayer(layerId);
					if (layer) {
						return originalSetPaintProperty.call(this, layerId, name, value);
					}
				} catch (e) {
					console.warn(`Could not set paint property ${name} on layer ${layerId}:`, e);
				}
			};

			// CRITICAL FIX: Wrap Map constructor to patch style.getOwnLayer
			// MT3D calls mbox.style.getOwnLayer(id).metadata = ... at geojson-layer.js:25
			// We must ensure getOwnLayer exists and returns layers with metadata

			const OriginalMap = maplibregl.Map;
			maplibregl.Map = function(...args) {
				console.log('[PATCH] MapLibre Map constructor intercepted');
				const map = new OriginalMap(...args);

				// Function to patch the style object
				const patchStyle = () => {
					if (map.style && !map.style._mtglPatched) {
						console.log('[PATCH] Patching map.style for getOwnLayer support');
						const style = map.style;

						// MapLibre doesn't have getOwnLayer, so we create it
						// Store layers in a Map for retrieval with metadata support
						if (!style._customLayers) {
							style._customLayers = {};
						}

						// Intercept the internal _layers if it exists
						const originalGetOwnLayer = style.getOwnLayer;

						style.getOwnLayer = function(id) {
							console.log('[PATCH] getOwnLayer called for:', id);

							// First try original method (Mapbox compatibility)
							if (typeof originalGetOwnLayer === 'function') {
								const layer = originalGetOwnLayer.call(this, id);
								if (layer) {
									console.log('[PATCH] Original method found layer:', id);
									return layer;
								}
							}

							// Check our custom layer store
							if (style._customLayers[id]) {
								console.log('[PATCH] Found in custom layer store:', id);
								return style._customLayers[id];
							}

							// Try to get from internal _layers (MapLibre internal structure)
							if (this._layers && this._layers[id]) {
								console.log('[PATCH] Found in _layers:', id);
								const layer = this._layers[id];
								// Cache it
								style._customLayers[id] = layer;
								return layer;
							}

							// Fallback: create a proxy layer object for the layer
							// This allows MT3D to set metadata even if we don't have the real layer object
							console.log('[PATCH] Creating proxy layer object for:', id);
							const proxyLayer = {
								id: id,
								metadata: {}
							};
							style._customLayers[id] = proxyLayer;
							return proxyLayer;
						};

						style._mtglPatched = true;
						console.log('[PATCH] Style.getOwnLayer created and patched');
					}
				};

				// Patch on style events
				setTimeout(patchStyle, 0);
				map.on('styledata', patchStyle);
				map.on('load', patchStyle);

				return map;
			};

			// Preserve prototype chain
			Object.setPrototypeOf(maplibregl.Map, OriginalMap);
			Object.setPrototypeOf(maplibregl.Map.prototype, OriginalMap.prototype);
		})();

		// NOW create Mapbox GL JS compatibility layer AFTER all patches are applied
		// This ensures MT3D uses our patched Map constructor
		console.log('[INIT] Creating mapboxgl compatibility layer');
		window.mapboxgl = window.maplibregl;
		window.mapboxgl.accessToken = 'pk.maplibre';
		console.log('[INIT] All patches applied, mapboxgl is ready for MT3D');
	</script>
	<script src="mini-tokyo-3d.min.js"></script>
	<!-- <script src="mt3d-plugin-precipitation.min.js"></script> -->
	<script src="mt3d-plugin-plateau.min.js"></script>
	<script>
		// Patch Mini Tokyo 3D's Map class AFTER it loads
		// This is the CRITICAL patch that fixes the metadata error
		(function() {
			if (window.mt3d && window.mt3d.Map) {
				const MT3DMapPrototype = window.mt3d.Map.prototype;

				if (MT3DMapPrototype.addLayer) {
					const originalMT3DAddLayer = MT3DMapPrototype.addLayer;

					MT3DMapPrototype.addLayer = function(layer, beforeId) {
						console.log('[MT3D-PATCH] addLayer called');

						// CRITICAL FIX: Patch the internal MapLibre map's style.getOwnLayer
						// MT3D accesses this.map.style.getOwnLayer() at geojson-layer.js:25
						if (this.map && this.map.style && !this.map.style._mtglPatched) {
							console.log('[MT3D-PATCH] Patching map.style.getOwnLayer!');
							const style = this.map.style;

							if (!style._customLayers) {
								style._customLayers = {};
							}

							const originalGetOwnLayer = style.getOwnLayer;

							style.getOwnLayer = function(id) {
								console.log('[MT3D-PATCH] getOwnLayer called for:', id);

								// Try original if it exists
								if (typeof originalGetOwnLayer === 'function') {
									const layer = originalGetOwnLayer.call(this, id);
									if (layer) {
										return layer;
									}
								}

								// Check cache
								if (style._customLayers[id]) {
									return style._customLayers[id];
								}

								// Try _layers
								if (this._layers && this._layers[id]) {
									const layer = this._layers[id];
									style._customLayers[id] = layer;
									return layer;
								}

								// Create proxy with metadata property
								console.log('[MT3D-PATCH] Creating proxy layer for:', id);
								const proxyLayer = {
									id: id,
									metadata: {}
								};
								style._customLayers[id] = proxyLayer;
								return proxyLayer;
							};

							style._mtglPatched = true;
							console.log('[MT3D-PATCH] style.getOwnLayer created!');
						}

						// Ensure layer has metadata
						if (layer && typeof layer === 'object' && !layer.hasOwnProperty('metadata')) {
							try {
								Object.defineProperty(layer, 'metadata', {
									value: {},
									writable: true,
									enumerable: true,
									configurable: true
								});
							} catch (e) {
								try {
									layer.metadata = {};
								} catch (e2) {}
							}
						}

						return originalMT3DAddLayer.call(this, layer, beforeId);
					};
				}

				console.log('Patched Mini Tokyo 3D Map class for metadata compatibility');
			} else {
				console.warn('Could not find mt3d.Map to patch');
			}
		})();
	</script>
</head>
<body style="width: 100%; height: 100%; margin: 0; padding: 0; position: absolute; overscroll-behavior: none;">
	<div class="header">
		<div class="title">
			<div class="logo"><i class="fa-solid fa-bus"></i>GTFS box</div>
			<div class="github"><i id= "github" class="fa-brands fa-github"></i></div>
			<div class="toggle"><i id= "toggle" class="fa-solid fa-angle-down"></i></div>
		</div>
		<div id="config-container" class="config-container">
			<div class="config">
				<div class="form">
					<div><select id="select"></select></div>
					<div><input id="gtfs-url" placeholder="GTFS zip file URL"></div>
					<div><input id="gtfs-vp-url"placeholder="GTFS Realtime VehiclePosition URL"></div>
					<div class="position">
						<div><input id="color" type="color" value="#000099"></div>
						<div><input id="zoom" placeholder="Zoom"></div>
						<div><input id="latitude" placeholder="Latitude"></div>
						<div><input id="longitude" placeholder="Longitude"></div>
						<div><input id="bearing" placeholder="Bearing"></div>
						<div><input id="pitch" placeholder="Pitch"></div>
						<div id="location"><i class="fa-solid fa-location-crosshairs"></i></div>
					</div>
				</div>
				<div class="submit">
					<div id="load"><i class="fa-solid fa-rotate-right"></i></div>
				</div>
			</div>
		</div>
	</div>
	<div id="map" class="content"></div>
	<script src="gtfs-box.js"></script>
</body>
</html>
