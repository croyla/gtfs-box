diff --git a/src/controls/clock-control.js b/src/controls/clock-control.js
index 3b905af..ad4a277 100644
--- a/src/controls/clock-control.js
+++ b/src/controls/clock-control.js
@@ -1,4 +1,4 @@
-import {Evented} from 'mapbox-gl';
+import {Evented} from 'maplibre-gl';
 import JapaneseHolidays from 'japanese-holidays';
 import {createElement} from '../helpers/helpers';
 
diff --git a/src/gpgpu/compute-renderer.js b/src/gpgpu/compute-renderer.js
index 23b8db1..d935d7d 100644
--- a/src/gpgpu/compute-renderer.js
+++ b/src/gpgpu/compute-renderer.js
@@ -1,4 +1,4 @@
-import {MercatorCoordinate} from 'mapbox-gl';
+import {MercatorCoordinate} from 'maplibre-gl';
 import {FullScreenQuad} from 'three/examples/jsm/postprocessing/Pass.js';
 import {ClampToEdgeWrapping, DataTexture, FloatType, GLSL3, MathUtils, NearestFilter, RGBAFormat, RGBAIntegerFormat, RGFormat, ShaderMaterial, UnsignedByteType, UnsignedIntType, WebGLRenderTarget} from 'three';
 import animation from '../animation';
diff --git a/src/helpers/helpers-deck.js b/src/helpers/helpers-deck.js
index a27e9c4..5252d8d 100644
--- a/src/helpers/helpers-deck.js
+++ b/src/helpers/helpers-deck.js
@@ -1,7 +1,8 @@
 export function pickObject(map, id, point) {
     const deck = map.__deck;
 
-    if (deck.deckPicker) {
+    // MapLibre compatibility: Check if deck exists
+    if (deck && deck.deckPicker) {
         const info = deck.pickObject({x: point.x, y: point.y, layerIds: [id]});
 
         if (info) {
diff --git a/src/helpers/helpers-mapbox.js b/src/helpers/helpers-mapbox.js
index ea94d47..0f00945 100644
--- a/src/helpers/helpers-mapbox.js
+++ b/src/helpers/helpers-mapbox.js
@@ -1,4 +1,4 @@
-import {LngLat, LngLatBounds} from 'mapbox-gl';
+import {LngLat, LngLatBounds} from 'maplibre-gl';
 import {parseCSSColor} from 'csscolorparser';
 import {lerp, luminance, valueOrDefault} from './helpers';
 import SunCalc from 'suncalc';
@@ -28,7 +28,13 @@ export function getBounds(coords) {
  * @param {Object} props - One or more properties to update
  */
 export function setLayerProps(map, id, props) {
-    map.getLayer(id).setProps(props);
+    // MapLibre compatibility: Check if layer has setProps method
+    const layer = map.getLayer(id);
+    if (layer && typeof layer.setProps === 'function') {
+        layer.setProps(props);
+    } else {
+        console.warn(`Layer ${id} does not support setProps method`);
+    }
 }
 
 /**
@@ -220,26 +226,36 @@ export function setSunlight(map, time) {
         };
     }
 
-    map.setLights([{
+    // MapLibre GL JS does not support setLights (Mapbox v3+ feature)
+    if (typeof map.setLights === 'function') {
+        map.setLights([{
         id: 'ambient',
         type: 'ambient',
         properties: {
-            color: `rgb(${ambient.r}, ${ambient.g}, ${ambient.b})`,
-            intensity: ambient.i
+        color: `rgb(${ambient.r}, ${ambient.g}, ${ambient.b})`,
+        intensity: ambient.i
         }
-    }, {
+        }, {
         id: 'directional',
         type: 'directional',
         properties: {
-            direction: ['literal', [sun.azimuth, sun.altitude]],
-            color: `rgb(${directional.r}, ${directional.g}, ${directional.b})`,
-            intensity: directional.i,
-            'cast-shadows': true,
-            'shadow-intensity': directional.w
+        direction: ['literal', [sun.azimuth, sun.altitude]],
+        color: `rgb(${directional.r}, ${directional.g}, ${directional.b})`,
+        intensity: directional.i,
+        'cast-shadows': true,
+        'shadow-intensity': directional.w
         }
-    }]);
+        }]);
+    }
 
-    map.setPaintProperty('sky', 'sky-atmosphere-sun', [sunAzimuth, sunAltitude]);
+    // MapLibre may not have 'sky' layer
+    try {
+        if (map.getLayer('sky')) {
+            map.setPaintProperty('sky', 'sky-atmosphere-sun', [sunAzimuth, sunAltitude]);
+        }
+    } catch (e) {
+        // Sky layer not available in MapLibre
+    }
 }
 
 /**
@@ -250,16 +266,42 @@ export function setSunlight(map, time) {
  * @returns {boolean} True if the background color of the map is dark
  */
 export function hasDarkBackground(map, actual) {
-    const light = map.getLights().filter(({type}) => type === 'ambient')[0],
-        lightColorElements = parseCSSColor(light.properties.color),
-        lightIntensity = light.properties.intensity,
-        lr = lightColorElements[0] / 255 * lightIntensity,
+    // MapLibre compatibility: getLights() doesn't exist, use default values
+    let lightColorElements, lightIntensity;
+
+    if (typeof map.getLights === 'function') {
+        const lights = map.getLights();
+        const light = lights ? lights.filter(({type}) => type === 'ambient')[0] : null;
+
+        if (light && light.properties) {
+            lightColorElements = parseCSSColor(light.properties.color);
+            lightIntensity = light.properties.intensity;
+        } else {
+            // Fallback if no ambient light found
+            lightColorElements = [255, 255, 255];
+            lightIntensity = 0.7;
+        }
+    } else {
+        // Default ambient light values (similar to daytime lighting)
+        lightColorElements = [255, 255, 255];
+        lightIntensity = 0.7;
+    }
+
+    const lr = lightColorElements[0] / 255 * lightIntensity,
         lg = lightColorElements[1] / 255 * lightIntensity,
         lb = lightColorElements[2] / 255 * lightIntensity;
 
     if (actual) {
         return BG_LAYER_IDS.reduce((value, id) => {
-            const paintProperties = map.style.getOwnLayer(id).paint,
+            // MapLibre doesn't have getOwnLayer - use _layers directly
+            const layer = map.style.getOwnLayer ? map.style.getOwnLayer(id) : map.style._layers[id];
+
+            // MapLibre compatibility: Ensure layer and paint exist
+            if (!layer || !layer.paint) {
+                return value;
+            }
+
+            const paintProperties = layer.paint,
                 {r, g, b} = paintProperties.get('background-color'),
                 a = paintProperties.get('background-opacity');
             return value + luminance({r: r * lr * a, g: g * lg * a, b: b * lb * a});
@@ -297,27 +339,53 @@ export function getStyleOpacities(map, metadataKey) {
         },
         opacities = [];
 
-    _order.map(id => _layers[id]).filter(({metadata}) =>
-        metadata && metadata[metadataKey]
-    ).forEach(({id, type, metadata}) => {
+    _order.map(id => _layers[id]).filter(layer =>
+        layer && layer.metadata && layer.metadata[metadataKey]
+    ).forEach(layer => {
+        // MapLibre compatibility: Ensure layer properties exist
+        if (!layer || !layer.id || !layer.type || !layer.metadata) {
+            return;
+        }
+
+        const {id, type, metadata} = layer;
         if (type === 'custom') {
             opacities.push({id, metadata});
             return;
         }
 
-        const key = `${type}-opacity`,
-            prop = propMapping[id] || valueOrDefault(map.getPaintProperty(id, key), 1);
+        const key = `${type}-opacity`;
+        let prop = propMapping[id];
+
+        // MapLibre compatibility: getPaintProperty might return undefined or throw
+        if (prop === undefined) {
+            try {
+                const paintProp = map.getPaintProperty(id, key);
+                prop = valueOrDefault(paintProp, 1);
+            } catch (e) {
+                // MapLibre may throw when accessing certain layer properties
+                console.warn(`Failed to get paint property for layer ${id}:`, e.message);
+                prop = 1;
+            }
+        }
+
+        // MapLibre compatibility: Ensure prop is valid before processing
+        if (!prop) {
+            opacities.push({id, key, opacity: 1, metadata});
+            return;
+        }
 
         if (!isNaN(prop)) {
             opacities.push({id, key, opacity: prop, metadata});
-        } else if (prop.stops) {
+        } else if (prop && prop.stops) {
             const opacity = [];
 
             prop.stops.forEach((item, index) => {
-                opacity.push({index, value: item[1]});
+                if (item && item[1] !== undefined) {
+                    opacity.push({index, value: item[1]});
+                }
             });
             opacities.push({id, key, opacity, metadata});
-        } else if (prop[0] === 'case' || prop[0] === 'interpolate') {
+        } else if (Array.isArray(prop) && prop.length > 0 && (prop[0] === 'case' || prop[0] === 'interpolate')) {
             const opacity = [];
 
             prop.forEach((item, index) => {
@@ -347,22 +415,44 @@ export function setStyleOpacities(map, styleOpacities, factorKey) {
             factor = metadata[factorKey];
         }
 
+        // MapLibre compatibility: Skip if factor is invalid
+        if (factor === undefined || factor === null) {
+            continue;
+        }
+
         if (key) {
-            if (Array.isArray(opacity)) {
-                prop = map.getPaintProperty(id, key);
-                for (const {index, value} of opacity) {
-                    const scaledOpacity = value * factor;
-
-                    if (prop.stops) {
-                        prop.stops[index][1] = scaledOpacity;
-                    } else {
-                        prop[index] = scaledOpacity;
+            try {
+                if (Array.isArray(opacity)) {
+                    prop = map.getPaintProperty(id, key);
+
+                    // MapLibre compatibility: Ensure prop exists before modifying
+                    if (!prop) {
+                        prop = 1;
+                    }
+
+                    for (const item of opacity) {
+                        // MapLibre compatibility: Ensure item has required properties
+                        if (!item || item.index === undefined || item.value === undefined) {
+                            continue;
+                        }
+
+                        const {index, value} = item;
+                        const scaledOpacity = value * factor;
+
+                        if (prop.stops) {
+                            prop.stops[index][1] = scaledOpacity;
+                        } else if (Array.isArray(prop)) {
+                            prop[index] = scaledOpacity;
+                        }
                     }
+                } else {
+                    prop = opacity * factor;
                 }
-            } else {
-                prop = opacity * factor;
+                map.setPaintProperty(id, key, prop);
+            } catch (e) {
+                // MapLibre may throw when accessing/setting certain layer properties
+                console.warn(`Failed to set paint property for layer ${id}:`, e.message);
             }
-            map.setPaintProperty(id, key, prop);
         } else {
             setLayerProps(map, id, {opacity: factor});
         }
diff --git a/src/index.esm.js b/src/index.esm.js
index 65924df..41b7db8 100644
--- a/src/index.esm.js
+++ b/src/index.esm.js
@@ -4,7 +4,7 @@ import {Panel} from './panels';
 import Plugin from './plugin';
 import Popup from './popup';
 import {ThreeLayer} from './layers';
-import mapboxgl from 'mapbox-gl';
+import mapboxgl from 'maplibre-gl';
 import * as three from 'three';
 import {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';
 import './css/loaders.css';
diff --git a/src/index.js b/src/index.js
index 080a5cf..351af1a 100644
--- a/src/index.js
+++ b/src/index.js
@@ -2,7 +2,7 @@ import Marker from './marker';
 import Map from './map';
 import {Panel} from './panels';
 import Popup from './popup';
-import mapboxgl from 'mapbox-gl';
+import mapboxgl from 'maplibre-gl';
 import * as three from 'three';
 import {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';
 import './css/loaders.css';
diff --git a/src/layers/geojson-layer.js b/src/layers/geojson-layer.js
index 0c7eac1..547b145 100644
--- a/src/layers/geojson-layer.js
+++ b/src/layers/geojson-layer.js
@@ -22,7 +22,12 @@ export default class {
 
         mbox.addLayer(new MapboxLayer(options), beforeId || 'poi');
         mbox.setLayerZoomRange(id, implementation.minzoom, implementation.maxzoom);
-        mbox.style.getOwnLayer(id).metadata = implementation.metadata;
+
+        // MapLibre doesn't have getOwnLayer - use _layers directly
+        const layer = mbox.style.getOwnLayer ? mbox.style.getOwnLayer(id) : mbox.style._layers[id];
+        if (layer) {
+            layer.metadata = implementation.metadata;
+        }
     }
 
 }
diff --git a/src/layers/three-layer.js b/src/layers/three-layer.js
index 053d3d4..030afee 100644
--- a/src/layers/three-layer.js
+++ b/src/layers/three-layer.js
@@ -118,8 +118,15 @@ export default class {
     _render(gl, matrix) {
         // These parameters are copied from mapbox-gl/src/geo/transform.js
         const {modelOrigin, mbox, renderer, camera, light, scene} = this,
-            {_fov, _camera, _horizonShift, pixelsPerMeter, worldSize, _pitch, width, height} = mbox.transform,
-            halfFov = _fov / 2,
+            {_fov, _camera, _horizonShift, pixelsPerMeter, worldSize, _pitch, width, height} = mbox.transform;
+
+        // MapLibre compatibility: Check if _camera.position exists
+        if (!_camera || !_camera.position) {
+            console.warn('ThreeLayer: _camera.position not available');
+            return;
+        }
+
+        const halfFov = _fov / 2,
             cameraToSeaLevelDistance = _camera.position[2] * worldSize / Math.cos(_pitch),
             horizonDistance = cameraToSeaLevelDistance / _horizonShift,
             undergroundDistance = 1000 * pixelsPerMeter / Math.cos(_pitch),
diff --git a/src/layers/tile-3d-layer.js b/src/layers/tile-3d-layer.js
index 68f6abf..ffa8140 100644
--- a/src/layers/tile-3d-layer.js
+++ b/src/layers/tile-3d-layer.js
@@ -36,7 +36,11 @@ export default class {
 
         mbox.addLayer(new MapboxLayer(options), beforeId || 'poi');
         mbox.setLayerZoomRange(implementation.id, implementation.minzoom, implementation.maxzoom);
-        mbox.__deck.props.effects = [new LightingEffect({ambientLight, directionalLight})];
+
+        // MapLibre compatibility: Check if __deck exists before setting effects
+        if (mbox.__deck && mbox.__deck.props) {
+            mbox.__deck.props.effects = [new LightingEffect({ambientLight, directionalLight})];
+        }
 
         if (lightColor === undefined) {
             me._tick();
diff --git a/src/layers/traffic-layer.js b/src/layers/traffic-layer.js
index 95c8e74..3802a8c 100644
--- a/src/layers/traffic-layer.js
+++ b/src/layers/traffic-layer.js
@@ -4,7 +4,7 @@ import ComputeRenderer from '../gpgpu/compute-renderer';
 import {colorToRGBArray, lerp, valueOrDefault} from '../helpers/helpers';
 import {hasDarkBackground} from '../helpers/helpers-mapbox';
 import {AircraftMeshSet, BusMeshSet, CarMeshSet} from '../mesh-sets';
-import {Point} from 'mapbox-gl';
+import {Point} from 'maplibre-gl';
 import {Color, Scene, MathUtils, WebGLRenderTarget, Vector3} from 'three';
 
 const MAX_UG_CARS = 1000;
@@ -31,9 +31,24 @@ export default class {
     onAdd(map, context) {
         const me = this,
             scene = context.scene,
-            zoom = map.getZoom(),
-            cameraZ = map.map.getFreeCameraOptions().position.z,
-            modelOrigin = map.getModelOrigin(),
+            zoom = map.getZoom();
+
+        // MapLibre compatibility: getFreeCameraOptions might not exist
+        let cameraZ;
+        try {
+            if (typeof map.map.getFreeCameraOptions === 'function') {
+                cameraZ = map.map.getFreeCameraOptions().position.z;
+            } else {
+                // Fallback: calculate camera Z from zoom and pitch
+                const pitch = map.map.getPitch();
+                cameraZ = Math.pow(2, 14 - zoom) * Math.cos(pitch * Math.PI / 180) * 512;
+            }
+        } catch (e) {
+            console.warn('Failed to get camera Z, using fallback:', e.message);
+            cameraZ = Math.pow(2, 14 - zoom) * 512; // Simple fallback
+        }
+
+        const modelOrigin = map.getModelOrigin(),
             modelScale = map.getModelScale(),
             textureWidth = context.renderer.capabilities.maxTextureSize;
 
@@ -115,7 +130,10 @@ export default class {
     onRemove(map) {
         const me = this;
 
-        me.computeRenderer.dispose();
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (me.computeRenderer) {
+            me.computeRenderer.dispose();
+        }
 
         me.ugCarMeshSet.dispose();
         me.ogCarMeshSet.dispose();
@@ -131,8 +149,14 @@ export default class {
     }
 
     prerender(map, context) {
-        const me = this,
-            textures = me.computeRenderer.compute(context, map.layerZoom);
+        const me = this;
+
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!me.computeRenderer) {
+            return;
+        }
+
+        const textures = me.computeRenderer.compute(context, map.layerZoom);
 
         me.ugCarMeshSet.setTextures(textures);
         me.ogCarMeshSet.setTextures(textures);
@@ -164,8 +188,15 @@ export default class {
     }
 
     setMode(viewMode, searchMode) {
-        const me = this,
-            currentOpacity = me.computeRenderer.getOpacity();
+        const me = this;
+
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!me.computeRenderer) {
+            console.warn('TrafficLayer: computeRenderer not initialized yet');
+            return;
+        }
+
+        const currentOpacity = me.computeRenderer.getOpacity();
         let ugOpacity, ogOpacity;
 
         if (searchMode !== 'none' && searchMode !== 'edit') {
@@ -191,8 +222,15 @@ export default class {
     }
 
     addBus(object) {
-        const me = this,
-            meshSet = me.busMeshSet,
+        const me = this;
+
+        // MapLibre compatibility: Check if map exists
+        if (!me.map) {
+            console.warn('TrafficLayer: map not initialized yet');
+            return;
+        }
+
+        const meshSet = me.busMeshSet,
             objects = me.busObjects,
             {x, y, z} = me.map.getModelPosition(object.coord, object.altitude),
             attributes = {
@@ -222,6 +260,13 @@ export default class {
 
     addObject(object) {
         const me = this;
+
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!me.computeRenderer) {
+            console.warn('TrafficLayer: computeRenderer not initialized yet');
+            return;
+        }
+
         let routeIndex, colorIndex, sectionIndex, sectionLength, delay;
 
         if (object.type === 'train') {
@@ -252,8 +297,14 @@ export default class {
             return;
         }
 
-        const me = this,
-            {x, y, z} = me.map.getModelPosition(object.coord, object.altitude),
+        const me = this;
+
+        // MapLibre compatibility: Check if map exists
+        if (!me.map) {
+            return;
+        }
+
+        const {x, y, z} = me.map.getModelPosition(object.coord, object.altitude),
             attributes = {
                 translation: [x, y, z],
                 rotationZ: MathUtils.degToRad(-object.bearing),
@@ -264,8 +315,14 @@ export default class {
     }
 
     updateObject(object, timeOffset, duration, accelerationTime, normalizedAcceleration, decelerationTime, normalizedDeceleration) {
-        const me = this,
-            sectionIndex = valueOrDefault(object.sectionIndex, 0),
+        const me = this;
+
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!me.computeRenderer) {
+            return;
+        }
+
+        const sectionIndex = valueOrDefault(object.sectionIndex, 0),
             sectionLength = valueOrDefault(object.sectionLength, 1);
 
         me.computeRenderer.updateInstance(object.instanceID, sectionIndex, sectionLength, timeOffset, duration, accelerationTime, normalizedAcceleration, decelerationTime, normalizedDeceleration);
@@ -273,6 +330,10 @@ export default class {
     }
 
     getObjectPosition(object) {
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!this.computeRenderer) {
+            return {x: 0, y: 0, z: 0};
+        }
         return this.computeRenderer.getInstancePosition(object.instanceID);
     }
 
@@ -320,6 +381,11 @@ export default class {
         const me = this,
             instanceID = object.instanceID;
 
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!me.computeRenderer) {
+            return Promise.resolve();
+        }
+
         if (instanceID !== undefined) {
             me.objects.delete(instanceID);
             delete object.instanceID;
@@ -331,8 +397,15 @@ export default class {
     }
 
     pickObject(mode, point) {
-        const me = this,
-            {pickingTexture, pixelBuffer} = me,
+        const me = this;
+
+        // MapLibre compatibility: Check if context exists
+        if (!me.context || !me.context.renderer || !me.context.camera) {
+            console.warn('TrafficLayer: context not initialized yet');
+            return undefined;
+        }
+
+        const {pickingTexture, pixelBuffer} = me,
             {renderer, camera} = me.context,
             rendererContext = renderer.getContext(),
             pixelRatio = window.devicePixelRatio,
@@ -368,14 +441,26 @@ export default class {
     }
 
     refreshDelayMarkers(actual) {
-        const me = this,
-            dark = hasDarkBackground(me.map.map, actual);
+        const me = this;
+
+        // MapLibre compatibility: Check if map exists
+        if (!me.map || !me.map.map) {
+            console.warn('TrafficLayer: map not initialized yet');
+            return;
+        }
+
+        const dark = hasDarkBackground(me.map.map, actual);
 
         me.ugCarMeshSet.refreshDelayMarkerMesh(dark);
         me.ogCarMeshSet.refreshDelayMarkerMesh(dark);
     }
 
     setTimeOffset(timeOffset) {
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!this.computeRenderer) {
+            console.warn('TrafficLayer: computeRenderer not initialized yet');
+            return;
+        }
         this.computeRenderer.setTimeOffset(timeOffset);
     }
 
@@ -383,6 +468,12 @@ export default class {
         const me = this,
             instanceID = object ? object.instanceID : -1;
 
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!me.computeRenderer) {
+            console.warn('TrafficLayer: computeRenderer not initialized yet');
+            return;
+        }
+
         me.computeRenderer.setMarked(instanceID);
         me.ugCarMeshSet.setMarkedInstanceID(instanceID);
         me.ogCarMeshSet.setMarkedInstanceID(instanceID);
@@ -394,6 +485,12 @@ export default class {
         const me = this,
             instanceID = object ? object.instanceID : -1;
 
+        // MapLibre compatibility: Check if computeRenderer exists
+        if (!me.computeRenderer) {
+            console.warn('TrafficLayer: computeRenderer not initialized yet');
+            return;
+        }
+
         me.computeRenderer.setTracked(instanceID);
         me.ugCarMeshSet.setTrackedInstanceID(instanceID);
         me.ogCarMeshSet.setTrackedInstanceID(instanceID);
diff --git a/src/map.js b/src/map.js
index 12c9e36..ee4b3bd 100644
--- a/src/map.js
+++ b/src/map.js
@@ -1,5 +1,5 @@
 import {featureEach} from '@turf/meta';
-import {Evented, FullscreenControl, LngLat, Map as Mapbox, MercatorCoordinate, NavigationControl} from 'mapbox-gl';
+import {Evented, FullscreenControl, LngLat, Map as Mapbox, MercatorCoordinate, NavigationControl} from 'maplibre-gl';
 import AnimatedPopup from 'mapbox-gl-animated-popup';
 import animation from './animation';
 import Clock from './clock';
@@ -691,26 +691,31 @@ export default class extends Evented {
         me.trafficLayer = new TrafficLayer({id: 'traffic'});
 
         // To move to the style file in v4.0
-        map.addLayer({
-            id: 'sky',
-            type: 'sky',
-            paint: {
-                'sky-opacity': [
-                    'interpolate',
-                    ['linear'],
-                    ['zoom'],
-                    0,
-                    0,
-                    5,
-                    0.3,
-                    8,
-                    1
-                ],
-                'sky-type': 'atmosphere',
-                'sky-atmosphere-color': 'hsl(220, 100%, 70%)',
-                'sky-atmosphere-sun-intensity': 20
-            }
-        }, 'background');
+        // MapLibre compatibility: Sky layer type not supported
+        try {
+            map.addLayer({
+                id: 'sky',
+                type: 'sky',
+                paint: {
+                    'sky-opacity': [
+                        'interpolate',
+                        ['linear'],
+                        ['zoom'],
+                        0,
+                        0,
+                        5,
+                        0.3,
+                        8,
+                        1
+                    ],
+                    'sky-type': 'atmosphere',
+                    'sky-atmosphere-color': 'hsl(220, 100%, 70%)',
+                    'sky-atmosphere-sun-intensity': 20
+                }
+            }, 'background');
+        } catch (e) {
+            console.warn('Sky layer not supported in MapLibre:', e.message);
+        }
         helpersMapbox.setSunlight(map, clock.getTime());
 
         map.setLayoutProperty('poi', 'text-field', [
@@ -796,7 +801,10 @@ export default class extends Evented {
         }
 
         // Workaround for deck.gl #3522
-        map.__deck.props.getCursor = () => map.getCanvas().style.cursor;
+        // MapLibre compatibility: Check if __deck exists before accessing
+        if (map.__deck && map.__deck.props) {
+            map.__deck.props.getCursor = () => map.getCanvas().style.cursor;
+        }
 
         map.addSource('odpt', {
             type: 'geojson',
@@ -828,18 +836,18 @@ export default class extends Evented {
                     paint: {
                         'railways': {
                             'line-color': color,
-                            'line-width': lineWidth,
-                            'line-emissive-strength': 1
+                            'line-width': lineWidth
+                            // MapLibre: 'line-emissive-strength' not supported
                         },
                         'stations': {
                             'fill-color': color,
-                            'fill-opacity': .7,
-                            'fill-emissive-strength': 1
+                            'fill-opacity': .7
+                            // MapLibre: 'fill-emissive-strength' not supported
                         },
                         'stations-outline': {
                             'line-color': ['get', 'outlineColor'],
-                            'line-width': lineWidth,
-                            'line-emissive-strength': 1
+                            'line-width': lineWidth
+                            // MapLibre: 'line-emissive-strength' not supported
                         }
                     }[key],
                     metadata: {
@@ -2312,8 +2320,8 @@ export default class extends Evented {
                                 width,
                                 22,
                                 ['*', width, 8]
-                            ],
-                            'line-emissive-strength': 1
+                            ]
+                            // MapLibre: 'line-emissive-strength' not supported
                         },
                         metadata: {
                             'mt3d:opacity-effect': true,
@@ -2343,13 +2351,13 @@ export default class extends Evented {
                             paint: {
                                 'busstops': {
                                     'fill-color': ['get', 'color'],
-                                    'fill-opacity': .7,
-                                    'fill-emissive-strength': 1
+                                    'fill-opacity': .7
+                                    // MapLibre: 'fill-emissive-strength' not supported
                                 },
                                 'busstops-outline': {
                                     'line-color': ['get', 'outlineColor'],
-                                    'line-width': lineWidth,
-                                    'line-emissive-strength': 1
+                                    'line-width': lineWidth
+                                    // MapLibre: 'line-emissive-strength' not supported
                                 }
                             }[key],
                             metadata: {
diff --git a/src/marker.js b/src/marker.js
index df4e24e..022f58a 100644
--- a/src/marker.js
+++ b/src/marker.js
@@ -1,5 +1,5 @@
 import {bindAll} from './helpers/helpers';
-import {Evented, Marker} from 'mapbox-gl';
+import {Evented, Marker} from 'maplibre-gl';
 
 /**
  * Creates a marker component.
