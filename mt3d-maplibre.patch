diff --git a/src/helpers/helpers-mapbox.js b/src/helpers/helpers-mapbox.js
index ea94d47..38c68bc 100644
--- a/src/helpers/helpers-mapbox.js
+++ b/src/helpers/helpers-mapbox.js
@@ -1,4 +1,4 @@
-import {LngLat, LngLatBounds} from 'mapbox-gl';
+import {LngLat, LngLatBounds} from 'maplibre-gl';
 import {parseCSSColor} from 'csscolorparser';
 import {lerp, luminance, valueOrDefault} from './helpers';
 import SunCalc from 'suncalc';
@@ -220,26 +220,36 @@ export function setSunlight(map, time) {
         };
     }
 
-    map.setLights([{
+    // MapLibre GL JS does not support setLights (Mapbox v3+ feature)
+    if (typeof map.setLights === 'function') {
+        map.setLights([{
         id: 'ambient',
         type: 'ambient',
         properties: {
-            color: `rgb(${ambient.r}, ${ambient.g}, ${ambient.b})`,
-            intensity: ambient.i
+        color: `rgb(${ambient.r}, ${ambient.g}, ${ambient.b})`,
+        intensity: ambient.i
         }
-    }, {
+        }, {
         id: 'directional',
         type: 'directional',
         properties: {
-            direction: ['literal', [sun.azimuth, sun.altitude]],
-            color: `rgb(${directional.r}, ${directional.g}, ${directional.b})`,
-            intensity: directional.i,
-            'cast-shadows': true,
-            'shadow-intensity': directional.w
+        direction: ['literal', [sun.azimuth, sun.altitude]],
+        color: `rgb(${directional.r}, ${directional.g}, ${directional.b})`,
+        intensity: directional.i,
+        'cast-shadows': true,
+        'shadow-intensity': directional.w
         }
-    }]);
+        }]);
+    }
 
-    map.setPaintProperty('sky', 'sky-atmosphere-sun', [sunAzimuth, sunAltitude]);
+    // MapLibre may not have 'sky' layer
+    try {
+        if (map.getLayer('sky')) {
+            map.setPaintProperty('sky', 'sky-atmosphere-sun', [sunAzimuth, sunAltitude]);
+        }
+    } catch (e) {
+        // Sky layer not available in MapLibre
+    }
 }
 
 /**
@@ -250,16 +260,42 @@ export function setSunlight(map, time) {
  * @returns {boolean} True if the background color of the map is dark
  */
 export function hasDarkBackground(map, actual) {
-    const light = map.getLights().filter(({type}) => type === 'ambient')[0],
-        lightColorElements = parseCSSColor(light.properties.color),
-        lightIntensity = light.properties.intensity,
-        lr = lightColorElements[0] / 255 * lightIntensity,
+    // MapLibre compatibility: getLights() doesn't exist, use default values
+    let lightColorElements, lightIntensity;
+
+    if (typeof map.getLights === 'function') {
+        const lights = map.getLights();
+        const light = lights ? lights.filter(({type}) => type === 'ambient')[0] : null;
+
+        if (light && light.properties) {
+            lightColorElements = parseCSSColor(light.properties.color);
+            lightIntensity = light.properties.intensity;
+        } else {
+            // Fallback if no ambient light found
+            lightColorElements = [255, 255, 255];
+            lightIntensity = 0.7;
+        }
+    } else {
+        // Default ambient light values (similar to daytime lighting)
+        lightColorElements = [255, 255, 255];
+        lightIntensity = 0.7;
+    }
+
+    const lr = lightColorElements[0] / 255 * lightIntensity,
         lg = lightColorElements[1] / 255 * lightIntensity,
         lb = lightColorElements[2] / 255 * lightIntensity;
 
     if (actual) {
         return BG_LAYER_IDS.reduce((value, id) => {
-            const paintProperties = map.style.getOwnLayer(id).paint,
+            // MapLibre doesn't have getOwnLayer - use _layers directly
+            const layer = map.style.getOwnLayer ? map.style.getOwnLayer(id) : map.style._layers[id];
+
+            // MapLibre compatibility: Ensure layer and paint exist
+            if (!layer || !layer.paint) {
+                return value;
+            }
+
+            const paintProperties = layer.paint,
                 {r, g, b} = paintProperties.get('background-color'),
                 a = paintProperties.get('background-opacity');
             return value + luminance({r: r * lr * a, g: g * lg * a, b: b * lb * a});
@@ -297,27 +333,53 @@ export function getStyleOpacities(map, metadataKey) {
         },
         opacities = [];
 
-    _order.map(id => _layers[id]).filter(({metadata}) =>
-        metadata && metadata[metadataKey]
-    ).forEach(({id, type, metadata}) => {
+    _order.map(id => _layers[id]).filter(layer =>
+        layer && layer.metadata && layer.metadata[metadataKey]
+    ).forEach(layer => {
+        // MapLibre compatibility: Ensure layer properties exist
+        if (!layer || !layer.id || !layer.type || !layer.metadata) {
+            return;
+        }
+
+        const {id, type, metadata} = layer;
         if (type === 'custom') {
             opacities.push({id, metadata});
             return;
         }
 
-        const key = `${type}-opacity`,
-            prop = propMapping[id] || valueOrDefault(map.getPaintProperty(id, key), 1);
+        const key = `${type}-opacity`;
+        let prop = propMapping[id];
+
+        // MapLibre compatibility: getPaintProperty might return undefined or throw
+        if (prop === undefined) {
+            try {
+                const paintProp = map.getPaintProperty(id, key);
+                prop = valueOrDefault(paintProp, 1);
+            } catch (e) {
+                // MapLibre may throw when accessing certain layer properties
+                console.warn(`Failed to get paint property for layer ${id}:`, e.message);
+                prop = 1;
+            }
+        }
+
+        // MapLibre compatibility: Ensure prop is valid before processing
+        if (!prop) {
+            opacities.push({id, key, opacity: 1, metadata});
+            return;
+        }
 
         if (!isNaN(prop)) {
             opacities.push({id, key, opacity: prop, metadata});
-        } else if (prop.stops) {
+        } else if (prop && prop.stops) {
             const opacity = [];
 
             prop.stops.forEach((item, index) => {
-                opacity.push({index, value: item[1]});
+                if (item && item[1] !== undefined) {
+                    opacity.push({index, value: item[1]});
+                }
             });
             opacities.push({id, key, opacity, metadata});
-        } else if (prop[0] === 'case' || prop[0] === 'interpolate') {
+        } else if (Array.isArray(prop) && prop.length > 0 && (prop[0] === 'case' || prop[0] === 'interpolate')) {
             const opacity = [];
 
             prop.forEach((item, index) => {
@@ -347,22 +409,44 @@ export function setStyleOpacities(map, styleOpacities, factorKey) {
             factor = metadata[factorKey];
         }
 
+        // MapLibre compatibility: Skip if factor is invalid
+        if (factor === undefined || factor === null) {
+            continue;
+        }
+
         if (key) {
-            if (Array.isArray(opacity)) {
-                prop = map.getPaintProperty(id, key);
-                for (const {index, value} of opacity) {
-                    const scaledOpacity = value * factor;
-
-                    if (prop.stops) {
-                        prop.stops[index][1] = scaledOpacity;
-                    } else {
-                        prop[index] = scaledOpacity;
+            try {
+                if (Array.isArray(opacity)) {
+                    prop = map.getPaintProperty(id, key);
+
+                    // MapLibre compatibility: Ensure prop exists before modifying
+                    if (!prop) {
+                        prop = 1;
+                    }
+
+                    for (const item of opacity) {
+                        // MapLibre compatibility: Ensure item has required properties
+                        if (!item || item.index === undefined || item.value === undefined) {
+                            continue;
+                        }
+
+                        const {index, value} = item;
+                        const scaledOpacity = value * factor;
+
+                        if (prop.stops) {
+                            prop.stops[index][1] = scaledOpacity;
+                        } else if (Array.isArray(prop)) {
+                            prop[index] = scaledOpacity;
+                        }
                     }
+                } else {
+                    prop = opacity * factor;
                 }
-            } else {
-                prop = opacity * factor;
+                map.setPaintProperty(id, key, prop);
+            } catch (e) {
+                // MapLibre may throw when accessing/setting certain layer properties
+                console.warn(`Failed to set paint property for layer ${id}:`, e.message);
             }
-            map.setPaintProperty(id, key, prop);
         } else {
             setLayerProps(map, id, {opacity: factor});
         }
